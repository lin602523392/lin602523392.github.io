{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Lin Weichao","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Name","slug":"Name","date":"2019-09-04T01:31:48.000Z","updated":"2019-09-04T01:31:48.902Z","comments":true,"path":"2019/09/04/Name/","link":"","permalink":"http://yoursite.com/2019/09/04/Name/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringDataRedis","slug":"SpringDataRedis","date":"2019-07-05T04:14:08.000Z","updated":"2019-07-05T04:14:38.857Z","comments":true,"path":"2019/07/05/SpringDataRedis/","link":"","permalink":"http://yoursite.com/2019/07/05/SpringDataRedis/","excerpt":"","text":"SpringDataRedis简介:123451.1 Spring Framework是领先的全栈Java / JEE应用程序框架。它提供了一个轻量级容器和一个非侵入式编程模型，它通过使用依赖注入，AOP和便携式服务抽象来实现。[NoSQL]存储系统为经典RDBMS提供了水平可扩展性和速度的替代方案。在实现方面，键值存储代表NoSQL空间中最大（和最老）的成员之一。Spring Data Redis（SDR）框架通过Spring的优秀基础架构支持消除了与商店交互所需的冗余任务和样板代码，可以轻松编写使用Redis键值存储的Spring应用程序。 坐标依赖:123456789101112131415161718192021&lt;!--缓存--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 基于XML配置:1.1创建配置properties配置文件. 123456redis.host=127.0.0.1 //IP redis.port=6379 //端口redis.pass= //密码redis.database=0 redis.maxIdle=300 //最大空闲数redis.maxWait=3000 //连接时的最大等待毫秒数 1.2创建applicationContext-redis.xml 1234567891011&lt;context:property-placeholder location=\"classpath:redis-config.properties\" /&gt; &lt;!-- redis 相关配置 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\" /&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWait&#125;\" /&gt; &lt;/bean&gt; &lt;bean id=\"JedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\" p:host-name=\"$&#123;redis.host&#125;\" p:port=\"$&#123;redis.port&#125;\" p:password=\"$&#123;redis.pass&#125;\" p:pool-config-ref=\"poolConfig\"/&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"JedisConnectionFactory\" /&gt; &lt;/bean&gt; 接口 描述 密钥类型操作 GeoOperations Redis的地理空间操作的，比如GEOADD，GEORADIUS… HashOperations Redis哈希操作 HyperLogLogOperations Redis的HyperLogLog操作，例如PFADD，PFCOUNT，… ListOperations Redis列表操作 SetOperations Redis设置了操作 ValueOperations Redis字符串（或值）操作 ZSetOperations Redis zset（或排序集）操作 键绑定操作 BoundGeoOperations Redis键绑定地理空间操作 BoundHashOperations Redis散列键绑定操作 BoundKeyOperations Redis键绑定操作 BoundListOperations Redis列出键绑定操作 BoundSetOperations Redis设置键绑定操作 BoundValueOperations Redis字符串（或值）键绑定操作 BoundZSetOperations Redis zset（或有序集）键绑定操作 Stirng操作:123redisTemplate.boundValueOps(\"name\").set(\"lwc\"); String str = (String) redisTemplate.boundValueOps(\"lwc\").get();redisTemplate.delete(\"name\");; Set类型操作123456789101112//增redisTemplate.boundSetOps(\"nameset\").add(\"路飞\"); redisTemplate.boundSetOps(\"nameset\").add(\"娜美\");//查Set members = redisTemplate.boundSetOps(\"nameset\").members();//删redisTemplate.boundSetOps(\"nameset\").remove(\"路飞\"); //删除整个集合redisTemplate.delete(\"nameset\"); List类型操作右压栈 后添加的对象排在后边 1234redisTemplate.boundListOps(\"namelist\").rightPush(\"路飞\"); List list = redisTemplate.boundListOps(\"namelist\").range(0, 10); //(0,1)查询全部 左压栈 后添加的对象排在前边 1234 redisTemplate.boundListOps(\"namelist\").leftPush(\"路飞\"); List list = redisTemplate.boundListOps(\"namelist\").range(0, 10); 根据索引查询元素 1String s = (String) redisTemplate.boundListOps(\"namelist\").index(1); 移除指定个数的值 1redisTemplate.boundListOps(\"namelist\").remove(1, \"路飞\"); Hash类型操作12345678910111213141516redisTemplate.boundHashOps(\"namehash\").put(\"c\", \"八戒\");redisTemplate.boundHashOps(\"namehash\").put(\"d\", \"沙僧\");Set s = redisTemplate.boundHashOps(\"namehash\").keys(); List values = redisTemplate.boundHashOps(\"namehash\").values();Object object = redisTemplate.boundHashOps(\"namehash\").get(\"b\");//根据KEY移除值redisTemplate.boundHashOps(\"namehash\").delete(\"c\");//推荐 //获取map键值对 redisTemplate.boundHashOperations.entries().forEach((m,n) -&gt; System.out.println(\"获取map键值对:\" + m + \"-\" + n)); ZSet类型操作123redisTemplate.boundZSetOps(\"namezset\").add(\"曹操\",100000);redisTemplate.boundZSetOps(\"namezset\").add(\"孙权\",0);redisTemplate.boundZSetOps(\"namezset\").add(\"刘备\",1000); 升序排列(低到高) 1Set namezset = redisTemplate.boundZSetOps(\"namezset\").range(0, -1); 倒叙排列 12 Set namezset = redisTemplate.boundZSetOps(\"namezset\").reverseRange(0,9); 增加分数 1redisTemplate.boundZSetOps(\"namezset\").incrementScore(\"孙权\",2000); 查询值和分数 123456 Set&lt;ZSetOperations.TypedTuple&gt; namezset = redisTemplate.boundZSetOps(\"namezset\").reverseRangeWithScores(0, -1);for(ZSetOperations.TypedTuple typedTuple:namezset)&#123; System.out.print(\"姓名：\"+typedTuple.getValue()); System.out.println(\"金币：\"+typedTuple.getScore());&#125; 过期时间设置1234 redisTemplate.boundValueOps(\"name\").set(\"itcast\");redisTemplate.boundValueOps(\"name\").expire(10,TimeUnit.SECONDS); //存值时指定过期时间和时间单位 缓存穿透、缓存击穿、缓存雪崩缓存穿透​ 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为负数的数据,主动式的恶意攻击,由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透 解决方案： ​ 1.接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； ​ 2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-0。这样可以防止攻击用户反复用同一个id暴力攻击。 ​ 3.缓存预热就是将数据提前加入到缓存中，当数据发生变更，再将最新的数据更新到缓存。 ​ 4.每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。 缓存击穿​ 缓存击穿是指缓存中没有但数据库中有的数据。这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 ​ 解决方案： ​ 1.设置热点数据永远不过期。 ​ 2.基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。 ​ 3.缓存预热 缓存雪崩​ 缓存雪崩是指缓存数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。 ​ 解决方案： ​ 1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 ​ 2.设置热点数据永远不过期。 ​ 3.使用缓存预热 ​ 4.用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。 限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。 好处： 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。 缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。","categories":[],"tags":[]}]}